<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#2C3E50">
    
    <title>VFIED - What Should I Eat?</title>
    
    <!-- PWA Icons -->
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icon-180.png">
    <link rel="manifest" href="/manifest.json">
    
    <style>
/* VFIED One-Button Experience Styles - COMPLETE EMBEDDED VERSION */

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  overflow-x: hidden;
  min-height: 100vh;
}

/* App Container */
#app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* Loading Screen */
.loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.loading-content {
  text-align: center;
}

.loading-content .logo {
  font-size: 4rem;
  margin-bottom: 1rem;
  animation: pulse 2s infinite;
}

.loading-text {
  font-size: 1.2rem;
  margin-bottom: 2rem;
  opacity: 0.9;
}

.loading-dots {
  display: flex;
  gap: 0.5rem;
  justify-content: center;
}

.loading-dots span {
  width: 8px;
  height: 8px;
  background: rgba(255, 255, 255, 0.7);
  border-radius: 50%;
  animation: bounce 1.4s infinite;
}

.loading-dots span:nth-child(2) { animation-delay: 0.2s; }
.loading-dots span:nth-child(3) { animation-delay: 0.4s; }

/* Main App */
.main-app {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  padding: 0;
}

.main-app.hidden {
  display: none;
}

/* Status Bar Spacer */
.status-bar-spacer {
  height: env(safe-area-inset-top, 20px);
  background: transparent;
}

/* Simple Header */
.simple-header {
  text-align: center;
  padding: 2rem 1rem 1rem;
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
}

.app-title {
  font-size: 2.5rem;
  font-weight: 800;
  margin-bottom: 0.5rem;
  background: linear-gradient(45deg, #fff, #f0f0f0);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.question {
  font-size: 1.4rem;
  font-weight: 300;
  margin-bottom: 1rem;
  opacity: 0.9;
}

.context-info {
  font-size: 0.9rem;
  padding: 0.5rem 1rem;
  background: rgba(255, 255, 255, 0.15);
  border-radius: 20px;
  display: inline-block;
  backdrop-filter: blur(5px);
  opacity: 0.8;
  max-width: 90%;
  transition: all 0.3s ease;
}

/* Current Settings Display */
.current-settings {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
  flex-wrap: wrap;
  justify-content: center;
}

.setting-tag {
  background: rgba(255, 255, 255, 0.2);
  color: white;
  padding: 0.25rem 0.75rem;
  border-radius: 15px;
  font-size: 0.8rem;
  backdrop-filter: blur(5px);
  border: 1px solid rgba(255, 255, 255, 0.3);
}

/* Quick Settings */
.quick-settings {
  position: relative;
  margin-bottom: 1rem;
}

.settings-btn {
  background: rgba(255, 255, 255, 0.15);
  border: 1px solid rgba(255, 255, 255, 0.3);
  color: white;
  padding: 0.5rem 1rem;
  border-radius: 20px;
  font-size: 0.9rem;
  cursor: pointer;
  backdrop-filter: blur(5px);
  transition: all 0.3s ease;
}

.settings-btn:hover {
  background: rgba(255, 255, 255, 0.25);
  transform: translateY(-1px);
}

.settings-panel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(255, 255, 255, 0.98);
  backdrop-filter: blur(20px);
  border-radius: 20px;
  padding: 2rem;
  width: 90vw;
  max-width: 400px;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
  border: 1px solid rgba(255, 255, 255, 0.3);
  z-index: 9999;
}

.settings-panel.hidden {
  display: none;
}

/* Add overlay background when settings open */
.settings-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(5px);
  z-index: 9998;
  display: none;
}

.settings-overlay.show {
  display: block;
}

.settings-panel h3 {
  color: #2C3E50;
  margin-bottom: 1rem;
  font-size: 1.2rem;
  text-align: center;
}

.setting-group {
  margin-bottom: 1.5rem;
}

.setting-group label {
  display: block;
  color: #2C3E50;
  font-weight: 600;
  margin-bottom: 0.5rem;
}

.location-select, .dietary-select {
  width: 100%;
  padding: 0.75rem;
  border: 2px solid #ddd;
  border-radius: 10px;
  font-size: 1rem;
  background: white;
  color: #2C3E50;
  transition: border-color 0.3s ease;
}

.location-select:focus, .dietary-select:focus {
  outline: none;
  border-color: #667eea;
}

.dietary-checkboxes {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: 0.5rem;
  margin-top: 0.5rem;
}

.dietary-checkboxes label {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-weight: normal;
  font-size: 0.9rem;
  cursor: pointer;
  padding: 0.5rem;
  border-radius: 8px;
  transition: background-color 0.2s ease;
}

.dietary-checkboxes label:hover {
  background: rgba(102, 126, 234, 0.1);
}

.dietary-checkboxes input[type="checkbox"] {
  cursor: pointer;
}

.custom-location {
  margin-top: 0.5rem;
  padding: 0.75rem;
  border: 2px solid #ddd;
  border-radius: 10px;
  width: 100%;
  font-size: 1rem;
}

.custom-location.hidden {
  display: none;
}

.settings-actions {
  display: flex;
  gap: 0.5rem;
  margin-top: 1.5rem;
}

.save-btn, .close-btn {
  flex: 1;
  padding: 0.75rem;
  border: none;
  border-radius: 10px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
}

.save-btn {
  background: #667eea;
  color: white;
}

.save-btn:hover {
  background: #5a6fd8;
  transform: translateY(-1px);
}

.close-btn {
  background: #f8f9fa;
  color: #2C3E50;
  border: 1px solid #ddd;
}

.close-btn:hover {
  background: #e9ecef;
}

/* One Button Main */
.one-button-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 2rem 1rem;
  min-height: 50vh;
}

/* The Giant Decision Button - FIXED TO ALWAYS BE CLICKABLE */
.decision-area {
  text-align: center;
  margin-bottom: 2rem;
}

.giant-decide-button {
  background: linear-gradient(145deg, #ff6b6b, #ee5a52);
  border: none;
  border-radius: 30px;
  padding: 2rem 3rem;
  box-shadow: 
    0 20px 40px rgba(0, 0, 0, 0.2),
    0 8px 16px rgba(255, 107, 107, 0.3),
    inset 0 2px 0 rgba(255, 255, 255, 0.2);
  cursor: pointer !important;
  transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  transform: translateY(0);
  min-width: 280px;
  position: relative;
  overflow: hidden;
  /* CRITICAL: Always allow clicks */
  pointer-events: auto !important;
  z-index: 10;
}

.giant-decide-button:hover {
  transform: translateY(-5px);
  box-shadow: 
    0 25px 50px rgba(0, 0, 0, 0.25),
    0 12px 24px rgba(255, 107, 107, 0.4),
    inset 0 2px 0 rgba(255, 255, 255, 0.2);
}

.giant-decide-button:active {
  transform: translateY(-2px);
}

/* FIXED: Button children don't block clicks */
.button-icon {
  font-size: 3rem;
  margin-bottom: 0.5rem;
  display: block;
  animation: gentle-bounce 2s infinite;
  pointer-events: none !important;
}

.button-text {
  font-size: 1.5rem;
  font-weight: 800;
  color: white;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  margin-bottom: 0.25rem;
  display: block;
  pointer-events: none !important;
}

.button-subtitle {
  font-size: 0.9rem;
  color: rgba(255, 255, 255, 0.8);
  font-weight: 400;
  pointer-events: none !important;
}

/* FIXED: Thinking state - only visual, don't disable clicks */
.giant-decide-button.thinking {
  opacity: 0.8;
  animation: gentle-pulse 1.5s infinite;
  pointer-events: auto !important;
  cursor: pointer !important;
}

/* Suggestion Result */
.suggestion-result {
  width: 100%;
  max-width: 400px;
  margin-top: 1rem;
  animation: fadeInUp 0.5s ease;
}

.suggestion-result.hidden {
  display: none;
}

.suggestion-card {
  background: rgba(255, 255, 255, 0.15);
  border-radius: 20px;
  padding: 2rem;
  text-align: center;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.2);
  margin-bottom: 1.5rem;
}

.food-emoji {
  font-size: 4rem;
  margin-bottom: 1rem;
  display: block;
}

.food-name {
  font-size: 1.8rem;
  font-weight: 700;
  margin-bottom: 0.5rem;
  color: white;
}

.food-description {
  font-size: 1rem;
  opacity: 0.9;
  margin-bottom: 1rem;
  line-height: 1.4;
}

.restaurant-info {
  font-size: 0.9rem;
  background: rgba(255, 255, 255, 0.1);
  padding: 0.5rem 1rem;
  border-radius: 15px;
  display: inline-block;
  opacity: 0.8;
}

/* Decision Actions */
.decision-actions {
  display: flex;
  gap: 1rem;
  margin-bottom: 1rem;
}

.action-btn {
  flex: 1;
  padding: 1rem;
  border: none;
  border-radius: 15px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer !important;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  pointer-events: auto !important;
}

.action-btn.accept {
  background: linear-gradient(145deg, #27AE60, #229954);
  color: white;
  box-shadow: 0 8px 16px rgba(39, 174, 96, 0.3);
}

.action-btn.accept:hover {
  transform: translateY(-2px);
  box-shadow: 0 12px 24px rgba(39, 174, 96, 0.4);
}

.action-btn.try-again {
  background: rgba(255, 255, 255, 0.15);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.3);
  backdrop-filter: blur(5px);
}

.action-btn.try-again:hover {
  background: rgba(255, 255, 255, 0.25);
  transform: translateY(-2px);
}

/* AI Insights */
.ai-insights {
  margin-top: 1rem;
}

.insights-toggle {
  background: rgba(255, 255, 255, 0.1);
  border: none;
  color: white;
  padding: 0.75rem 1rem;
  border-radius: 12px;
  font-size: 0.9rem;
  cursor: pointer !important;
  width: 100%;
  transition: all 0.3s ease;
  backdrop-filter: blur(5px);
  pointer-events: auto !important;
}

.insights-toggle:hover {
  background: rgba(255, 255, 255, 0.2);
}

.insights-content {
  margin-top: 1rem;
  animation: fadeIn 0.3s ease;
}

.insights-content.hidden {
  display: none;
}

.cultural-note,
.personal-note,
.weather-note {
  background: rgba(255, 255, 255, 0.1);
  padding: 1rem;
  border-radius: 12px;
  margin-bottom: 0.5rem;
  font-size: 0.9rem;
  line-height: 1.4;
  backdrop-filter: blur(5px);
}

.cultural-note strong,
.personal-note strong,
.weather-note strong {
  display: block;
  margin-bottom: 0.25rem;
}

/* Simple Footer */
.simple-footer {
  text-align: center;
  padding: 1rem;
  background: rgba(0, 0, 0, 0.1);
  backdrop-filter: blur(10px);
}

.stats-line {
  font-size: 0.9rem;
  opacity: 0.8;
  margin-bottom: 0.5rem;
}

.ai-status {
  font-size: 0.8rem;
  opacity: 0.6;
}

/* Bottom Safe Area */
.bottom-safe-area {
  height: env(safe-area-inset-bottom, 20px);
  background: rgba(0, 0, 0, 0.1);
}

/* Animations */
@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

@keyframes bounce {
  0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
  40% { transform: translateY(-10px); }
  60% { transform: translateY(-5px); }
}

@keyframes gentle-bounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-5px); }
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeInUp {
  from { 
    opacity: 0; 
    transform: translateY(20px); 
  }
  to { 
    opacity: 1; 
    transform: translateY(0); 
  }
}

@keyframes gentle-pulse {
  0%, 100% { opacity: 0.8; }
  50% { opacity: 0.6; }
}

/* Responsive Design */
@media (max-width: 480px) {
  .simple-header {
    padding: 1.5rem 1rem 1rem;
  }
  
  .app-title {
    font-size: 2rem;
  }
  
  .question {
    font-size: 1.2rem;
  }
  
  .giant-decide-button {
    padding: 1.5rem 2rem;
    min-width: 240px;
  }
  
  .button-text {
    font-size: 1.3rem;
  }
  
  .button-icon {
    font-size: 2.5rem;
  }
  
  .suggestion-card {
    padding: 1.5rem;
  }
  
  .food-name {
    font-size: 1.5rem;
  }
  
  .decision-actions {
    flex-direction: column;
  }
  
  .settings-panel {
    width: 95vw;
    padding: 1.5rem;
  }
  
  .dietary-checkboxes {
    grid-template-columns: 1fr;
  }

  .settings-actions {
    flex-direction: column;
  }
}

@media (max-height: 600px) {
  .one-button-main {
    padding: 1rem;
    min-height: auto;
  }
  
  .simple-header {
    padding: 1rem;
  }
}

/* Focus States for Accessibility */
.giant-decide-button:focus,
.action-btn:focus,
.insights-toggle:focus {
  outline: 2px solid rgba(255, 255, 255, 0.5);
  outline-offset: 2px;
}

/* CRITICAL: Force all buttons to be clickable */
button {
  pointer-events: auto !important;
  cursor: pointer !important;
}

/* Force main button clickability */
#decide-button {
  pointer-events: auto !important;
  cursor: pointer !important;
}

/* Ensure button children never block clicks */
#decide-button * {
  pointer-events: none !important;
}

/* Override any disabled state */
.giant-decide-button:disabled {
  pointer-events: auto !important;
  cursor: pointer !important;
  opacity: 0.8 !important;
}

/* Force clickability for all interactive elements */
.giant-decide-button,
.action-btn,
.insights-toggle,
.settings-btn,
.save-btn,
.close-btn {
  pointer-events: auto !important;
  cursor: pointer !important;
}/* Mood Section */
.mood-section {
    margin: 1.5rem 0;
    padding: 1rem;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 15px;
    backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.mood-section h3 {
    margin: 0 0 1rem 0;
    font-size: 1.1rem;
    text-align: center;
    opacity: 0.9;
}

/* Quick Mood Buttons */
.mood-quick-options {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
    justify-content: center;
}

.mood-quick-btn {
    background: rgba(255, 255, 255, 0.15);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: white;
    padding: 0.5rem 0.75rem;
    border-radius: 20px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(5px);
}

.mood-quick-btn:hover {
    background: rgba(255, 255, 255, 0.25);
    transform: translateY(-1px);
}

/* Mood Input */
.mood-input-container {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.mood-input {
    flex: 1;
    padding: 0.75rem;
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.1);
    color: white;
    font-size: 0.9rem;
    backdrop-filter: blur(5px);
}

.mood-input::placeholder {
    color: rgba(255, 255, 255, 0.6);
}

.mood-detect-btn {
    background: linear-gradient(145deg, #667eea, #764ba2);
    border: none;
    color: white;
    padding: 0.75rem 1rem;
    border-radius: 10px;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    white-space: nowrap;
}

.mood-detect-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
}

/* Detected Moods */
.detected-moods {
    animation: fadeIn 0.3s ease;
}

.detected-moods.hidden {
    display: none;
}

.mood-result {
    background: rgba(255, 255, 255, 0.15);
    padding: 1rem;
    border-radius: 10px;
    text-align: center;
    backdrop-filter: blur(5px);
}

.mood-tags {
    display: flex;
    gap: 0.5rem;
    margin: 0.5rem 0;
    flex-wrap: wrap;
    justify-content: center;
}

.mood-tag {
    background: rgba(102, 126, 234, 0.3);
    color: white;
    padding: 0.25rem 0.75rem;
    border-radius: 15px;
    font-size: 0.8rem;
    border: 1px solid rgba(102, 126, 234, 0.5);
}

.use-mood-btn {
    background: linear-gradient(145deg, #27AE60, #229954);
    border: none;
    color: white;
    padding: 0.75rem 1.5rem;
    border-radius: 10px;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    margin-top: 0.5rem;
    transition: all 0.3s ease;
}

.use-mood-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(39, 174, 96, 0.3);
}

/* Mood Context in Suggestion */
.mood-context {
    background: rgba(102, 126, 234, 0.2);
    padding: 0.75rem;
    border-radius: 10px;
    margin-bottom: 1rem;
    text-align: center;
    border: 1px solid rgba(102, 126, 234, 0.3);
    backdrop-filter: blur(5px);
}

.mood-context.hidden {
    display: none;
}

.mood-match {
    font-size: 0.9rem;
    color: white;
}

/* Error states */
.mood-error {
    background: rgba(220, 53, 69, 0.2);
    color: white;
    padding: 0.75rem;
    border-radius: 10px;
    text-align: center;
    border: 1px solid rgba(220, 53, 69, 0.3);
}

.mood-loading {
    text-align: center;
    padding: 0.75rem;
    color: rgba(255, 255, 255, 0.8);
    font-style: italic;
}

/* Responsive Design */
@media (max-width: 480px) {
    .mood-quick-options {
        flex-direction: column;
        align-items: center;
    }
    
    .mood-quick-btn {
        width: 100%;
        max-width: 200px;
    }
    
    .mood-input-container {
        flex-direction: column;
    }
    
    .mood-detect-btn {
        width: 100%;
    }
}
    </style>
</head>
<body>
    <div id="app">
        <!-- Loading Screen -->
        <div id="loading-screen" class="loading-screen">
            <div class="loading-content">
                <div class="logo">üçΩÔ∏è</div>
                <div class="loading-text">Waking up your food friend...</div>
                <div class="loading-dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>

        <!-- Main One-Button App -->
        <div id="main-app" class="main-app hidden">
            <!-- Status Bar Spacer -->
            <div class="status-bar-spacer"></div>
            
            <!-- Simple Header -->
            <header class="simple-header">
              <h1 class="app-title">VFIED</h1>
              <p class="question">What should I eat?</p>
              <div class="context-info" id="context-info">
                  ü§ñ Analyzing your situation...
              </div>
          
              <!-- Current Settings Display -->
              <div class="current-settings" id="current-settings">
                  <span class="setting-tag" id="location-tag">üìç Auto-detect</span>
                  <span class="setting-tag hidden" id="dietary-tag">üå± No restrictions</span>
              </div>
          
              <!-- Quick Settings -->
              <div class="quick-settings">
                  <button id="settings-btn" class="settings-btn">‚öôÔ∏è Preferences</button>
              </div>
          
              <!-- üÜï ADD THIS MOOD SECTION HERE -->
              <div class="mood-section" id="mood-section">
                  <h3>üß† How are you feeling?</h3>
                  
                  <!-- Quick Mood Options -->
                  <div class="mood-quick-options">
                      <button class="mood-quick-btn" onclick="quickMood('tired')">üò¥ Tired</button>
                      <button class="mood-quick-btn" onclick="quickMood('stressed')">üò∞ Stressed</button>
                      <button class="mood-quick-btn" onclick="quickMood('celebrating')">üéâ Celebrating</button>
                      <button class="mood-quick-btn" onclick="quickMood('post-workout')">üí™ Post-workout</button>
                      <button class="mood-quick-btn" onclick="quickMood('hungry')">ü§§ Hungry</button>
                  </div>
          
                  <!-- Custom Mood Input -->
                  <div class="mood-input-container">
                      <input 
                          type="text" 
                          id="mood-input" 
                          placeholder="Or describe your mood... (e.g., tired but celebrating, stressed and need comfort)"
                          class="mood-input"
                      >
                      <button id="detect-mood-btn" class="mood-detect-btn">‚ú® Detect</button>
                  </div>
          
                  <!-- Detected Moods Display -->
                  <div id="detected-moods" class="detected-moods hidden"></div>
              </div>
          </header>

            <!-- Settings Overlay (moved outside header) -->
            <div id="settings-overlay" class="settings-overlay"></div>
            <div id="settings-panel" class="settings-panel hidden">
                <h3>üçΩÔ∏è Food Preferences</h3>
                
                <!-- Location Override -->
                <div class="setting-group">
                    <label>üìç Location:</label>
                    <select id="location-select" class="location-select">
                        <option value="">Auto-detect my location</option>
                        <option value="london,uk">üè∞ London, UK</option>
                        <option value="nairobi,ke">ü¶Å Nairobi, Kenya</option>
                        <option value="tokyo,jp">üóº Tokyo, Japan</option>
                        <option value="newyork,us">üóΩ New York, USA</option>
                        <option value="paris,fr">üóº Paris, France</option>
                        <option value="mumbai,in">üèôÔ∏è Mumbai, India</option>
                        <option value="lagos,ng">üåÜ Lagos, Nigeria</option>
                        <option value="sydney,au">üèÑ Sydney, Australia</option>
                        <option value="custom">‚úèÔ∏è Custom location...</option>
                    </select>
                    <input id="custom-location" type="text" placeholder="Enter: City, Country" class="custom-location hidden">
                </div>

                <!-- Dietary Restrictions -->
                <div class="setting-group">
                    <label>üå± Dietary Restrictions:</label>
                    <div class="dietary-checkboxes">
                        <label><input type="checkbox" value="vegetarian"> üå± Vegetarian</label>
                        <label><input type="checkbox" value="vegan"> ü•¨ Vegan</label>
                        <label><input type="checkbox" value="gluten-free"> üåæ Gluten-Free</label>
                        <label><input type="checkbox" value="dairy-free"> ü•õ Dairy-Free</label>
                        <label><input type="checkbox" value="keto"> ü•© Keto</label>
                        <label><input type="checkbox" value="halal"> ‚ò™Ô∏è Halal</label>
                        <label><input type="checkbox" value="kosher"> ‚ú°Ô∏è Kosher</label>
                        <label><input type="checkbox" value="paleo"> ü¶¥ Paleo</label>
                    </div>
                </div>

                <div class="settings-actions">
                    <button id="save-settings" class="save-btn">üíæ Save</button>
                    <button id="close-settings" class="close-btn">‚ùå Close</button>
                </div>
            </div>

            <!-- The One Button -->
            <main class="one-button-main">
                <div class="decision-area">
                    <button id="decide-button" class="giant-decide-button">
                        <div class="button-icon" id="button-icon">üéØ</div>
                        <div class="button-text" id="button-text">DECIDE FOR ME</div>
                        <div class="button-subtitle">I'll figure it out for you</div>
                    </button>
                </div>

                <!-- Quick Suggestion Display -->
                <div id="suggestion-result" class="suggestion-result hidden">
                    <div class="suggestion-card">
                      <div id="mood-context" class="mood-context hidden">
                        <div class="mood-match" id="mood-match-text">
                            üß† <strong>Mood Match:</strong> Perfect for when you're feeling...
                        </div>
                    </div>
                        <div class="food-emoji" id="result-emoji">üçï</div>
                        <div class="food-info">
                            <h2 class="food-name" id="result-name">Pizza Night!</h2>
                            <p class="food-description" id="result-description">
                                Perfect for this tired Tuesday evening
                            </p>
                            <div class="restaurant-info" id="restaurant-info">
                                üìç Tony's Pizza (0.8km, open until 11pm)
                            </div>
                        </div>
                    </div>

                    <div class="decision-actions">
                        <button id="accept-btn" class="action-btn accept">
                            ‚úÖ YES, GET IT!
                        </button>
                        <button id="try-again-btn" class="action-btn try-again">
                            üîÑ TRY AGAIN
                        </button>
                    </div>

                    <!-- AI Insights (Collapsible) -->
                    <div class="ai-insights" id="ai-insights">
                        <button class="insights-toggle" id="insights-toggle">
                            ü§ñ Why this choice? ‚Üì
                        </button>
                        <div class="insights-content hidden" id="insights-content">
                            <div class="cultural-note" id="cultural-note"></div>
                            <div class="personal-note" id="personal-note"></div>
                            <div class="weather-note" id="weather-note"></div>
                        </div>
                    </div>
                </div>
            </main>

            <!-- Simple Footer Stats -->
            <footer class="simple-footer">
                <div class="stats-line">
                    <span id="decisions-count">12</span> decisions made ‚Ä¢ 
                    <span id="time-saved">42</span> minutes saved
                </div>
                <div class="ai-status" id="ai-status">
                    ü§ñ AI ready with cultural intelligence
                </div>
            </footer>

            <!-- Bottom Safe Area -->
            <div class="bottom-safe-area"></div>
        </div>
    </div>

    <script>
    // RESTORED REAL AI INTEGRATION - YOUR BUSINESS APP VERSION
    
    console.log('üöÄ VFIED Real AI App Loading...');

    // ==================== SETTINGS SYSTEM ====================
    
    let userSettings = {
        location: null,
        dietary: [],
        customLocation: null
    };

    function loadSettings() {
        try {
            const saved = localStorage.getItem('vfied_user_settings');
            if (saved) {
                userSettings = { ...userSettings, ...JSON.parse(saved) };
                console.log('üìÇ Loaded settings:', userSettings);
            }
        } catch (error) {
            console.error('Settings load error:', error);
        }
    }

    function saveSettings() {
        try {
            localStorage.setItem('vfied_user_settings', JSON.stringify(userSettings));
            console.log('üíæ Settings saved:', userSettings);
            notifyMainApp();
        } catch (error) {
            console.error('Settings save error:', error);
        }
    }

    function notifyMainApp() {
        const event = new CustomEvent('vfied-settings-updated', {
            detail: userSettings
        });
        window.dispatchEvent(event);
        
        if (window.vfiedAppInstance) {
            console.log('üì¢ Notifying main app directly');
            window.vfiedAppInstance.updatePreferences(userSettings);
        }
    }

    function updateSettingsDisplay() {
        const locationTag = document.getElementById('location-tag');
        const dietaryTag = document.getElementById('dietary-tag');

        if (userSettings.location) {
            const locationMap = {
                'london,uk': 'üè∞ London',
                'nairobi,ke': 'ü¶Å Nairobi', 
                'tokyo,jp': 'üóº Tokyo',
                'newyork,us': 'üóΩ New York',
                'paris,fr': 'üóº Paris',
                'mumbai,in': 'üèôÔ∏è Mumbai',
                'lagos,ng': 'üåÜ Lagos',
                'sydney,au': 'üèÑ Sydney'
            };
            
            locationTag.textContent = locationMap[userSettings.location] || 
                (userSettings.customLocation ? `üìç ${userSettings.customLocation}` : 'üìç Custom');
        } else {
            locationTag.textContent = 'üìç Auto-detect';
        }

        if (userSettings.dietary.length > 0) {
            const dietaryEmojis = {
                'vegetarian': 'üå±', 'vegan': 'ü•¨', 'gluten-free': 'üåæ',
                'dairy-free': 'ü•õ', 'keto': 'ü•©', 'halal': '‚ò™Ô∏è',
                'kosher': '‚ú°Ô∏è', 'paleo': 'ü¶¥'
            };
            
            const icons = userSettings.dietary.map(d => dietaryEmojis[d] || 'üçΩÔ∏è').join('');
            dietaryTag.textContent = `${icons} ${userSettings.dietary.length} restriction${userSettings.dietary.length > 1 ? 's' : ''}`;
            dietaryTag.classList.remove('hidden');
        } else {
            dietaryTag.classList.add('hidden');
        }
    }

    function getCurrentSettings() {
        const settings = { dietary: userSettings.dietary };

        if (userSettings.location && userSettings.location !== 'custom') {
            const locationMap = {
                'london,uk': { city: 'London', country: 'United Kingdom', countryCode: 'GB' },
                'nairobi,ke': { city: 'Nairobi', country: 'Kenya', countryCode: 'KE' },
                'tokyo,jp': { city: 'Tokyo', country: 'Japan', countryCode: 'JP' },
                'newyork,us': { city: 'New York', country: 'United States', countryCode: 'US' },
                'paris,fr': { city: 'Paris', country: 'France', countryCode: 'FR' },
                'mumbai,in': { city: 'Mumbai', country: 'India', countryCode: 'IN' },
                'lagos,ng': { city: 'Lagos', country: 'Nigeria', countryCode: 'NG' },
                'sydney,au': { city: 'Sydney', country: 'Australia', countryCode: 'AU' }
            };
            settings.location = locationMap[userSettings.location];
        } else if (userSettings.customLocation) {
            const parts = userSettings.customLocation.split(',').map(s => s.trim());
            if (parts.length >= 2) {
                settings.location = { city: parts[0], country: parts[1] };
            }
        }

        return settings;
    }

    function setupSettingsPanel() {
        const settingsBtn = document.getElementById('settings-btn');
        const settingsPanel = document.getElementById('settings-panel');
        const settingsOverlay = document.getElementById('settings-overlay');
        const saveBtn = document.getElementById('save-settings');
        const closeBtn = document.getElementById('close-settings');
        const locationSelect = document.getElementById('location-select');
        const customLocationInput = document.getElementById('custom-location');

        if (!settingsBtn || !settingsPanel) return;

        function showSettings() {
            settingsPanel.classList.remove('hidden');
            settingsOverlay.classList.add('show');
            loadCurrentSettingsIntoPanel();
        }

        function hideSettings() {
            settingsPanel.classList.add('hidden');
            settingsOverlay.classList.remove('show');
        }

        settingsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            showSettings();
        });

        settingsOverlay.addEventListener('click', hideSettings);

        if (locationSelect) {
            locationSelect.addEventListener('change', () => {
                if (locationSelect.value === 'custom') {
                    customLocationInput?.classList.remove('hidden');
                    customLocationInput?.focus();
                } else {
                    customLocationInput?.classList.add('hidden');
                }
            });
        }

        if (saveBtn) {
            saveBtn.addEventListener('click', () => {
                saveSettingsFromPanel();
                hideSettings();
                updateSettingsDisplay();
                
                const contextInfo = document.getElementById('context-info');
                if (contextInfo) {
                    contextInfo.textContent = '‚úÖ Settings saved! Ready for personalized suggestions.';
                }
            });
        }

        if (closeBtn) {
            closeBtn.addEventListener('click', hideSettings);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !settingsPanel.classList.contains('hidden')) {
                hideSettings();
            }
        });
    }

    function loadCurrentSettingsIntoPanel() {
        const locationSelect = document.getElementById('location-select');
        const customLocationInput = document.getElementById('custom-location');
        const dietaryCheckboxes = document.querySelectorAll('.dietary-checkboxes input[type="checkbox"]');

        if (locationSelect) {
            locationSelect.value = userSettings.location || '';
            if (userSettings.location === 'custom' && userSettings.customLocation) {
                customLocationInput?.classList.remove('hidden');
                if (customLocationInput) customLocationInput.value = userSettings.customLocation;
            } else {
                customLocationInput?.classList.add('hidden');
            }
        }

        dietaryCheckboxes.forEach(checkbox => {
            checkbox.checked = userSettings.dietary.includes(checkbox.value);
        });
    }

    function saveSettingsFromPanel() {
      const locationSelect = document.getElementById('location-select');
      const customLocationInput = document.getElementById('custom-location');
      const dietaryCheckboxes = document.querySelectorAll('.dietary-checkboxes input[type="checkbox"]');

      if (locationSelect) {
          const selectedValue = locationSelect.value;
          userSettings.location = null; // Reset first
          
          if (selectedValue && selectedValue !== '') {
              if (selectedValue === 'custom') {
                  userSettings.customLocation = customLocationInput?.value?.trim() || null;
                  if (userSettings.customLocation) {
                      const parts = userSettings.customLocation.split(',').map(s => s.trim());
                      if (parts.length >= 2) {
                          userSettings.location = { 
                              city: parts[0], 
                              country: parts[1],
                              country_code: getCountryCode(parts[1])
                          };
                      }
                  }
              } else {
                  // üî• FIX: Correct location mapping
                  const locationMap = {
                      'london,uk': { city: 'London', country: 'United Kingdom', country_code: 'GB' },
                      'nairobi,ke': { city: 'Nairobi', country: 'Kenya', country_code: 'KE' },
                      'tokyo,jp': { city: 'Tokyo', country: 'Japan', country_code: 'JP' },
                      'newyork,us': { city: 'New York', country: 'United States', country_code: 'US' },
                      'paris,fr': { city: 'Paris', country: 'France', country_code: 'FR' },
                      'mumbai,in': { city: 'Mumbai', country: 'India', country_code: 'IN' },
                      'lagos,ng': { city: 'Lagos', country: 'Nigeria', country_code: 'NG' },
                      'sydney,au': { city: 'Sydney', country: 'Australia', country_code: 'AU' }
                  };
                  
                  userSettings.location = locationMap[selectedValue] || null;
                  userSettings.customLocation = null;
                  
                  console.log('üîß Settings: Selected location:', selectedValue, '‚Üí', userSettings.location);
              }
          }
      }

      userSettings.dietary = Array.from(dietaryCheckboxes)
          .filter(cb => cb.checked)
          .map(cb => cb.value);

      saveSettings();
      console.log('‚úÖ Settings saved:', userSettings);
      updateSettingsDisplay();
  }


// üî• ADD: Helper function for country codes
function getCountryCode(country) {
    const countryMap = {
        'Kenya': 'KE',
        'United Kingdom': 'GB', 
        'UK': 'GB',
        'United States': 'US',
        'USA': 'US',
        'Japan': 'JP',
        'France': 'FR',
        'Germany': 'DE',
        'Nigeria': 'NG',
        'India': 'IN',
        'Australia': 'AU'
    };
    return countryMap[country] || 'US';
}

    // ==================== REAL AI SERVICE INTEGRATION ====================
    
    // REAL AI Functions - calls your actual MCP server and OpenAI
    async function getAIQuickDecision(context = {}) {
    console.log('üé≤ Getting REAL AI quick decision with settings...');
    
    try {
        const userPrefs = getCurrentSettings();
        console.log('üìç Using location:', userPrefs.location);
        console.log('üå± Using dietary:', userPrefs.dietary);
        
        // üî• FIX: Ensure location is properly formatted
        let locationData = userPrefs.location;
        if (!locationData && context.defaultLocation) {
            locationData = context.defaultLocation;
        }
        
        // Fallback to detected location from UI
        const locationTag = document.getElementById('location-tag');
        if (!locationData && locationTag?.textContent?.includes('Nairobi')) {
            locationData = {
                city: 'Nairobi',
                country: 'Kenya',
                country_code: 'KE'
            };
        }
        
        console.log('üìç Final location data:', locationData);
        
        // üî• FIX: Create proper MCP request payload with REQUIRED mood
        const payload = {
            location: locationData || {
                city: 'London',
                country: 'United Kingdom',
                country_code: 'GB'
            },
            dietary: userPrefs.dietary || [],
            budget: context.budget || 'medium',
            menu_source: 'global_database'
        };

        // üß† CRITICAL FIX: Always provide mood (required by server)
        if (currentMood && currentMood.text) {
            payload.mood_text = currentMood.text;
            console.log('üß† Including mood in request:', currentMood.text);
        } else {
            // üî• FALLBACK: Provide default mood to satisfy server requirement
            payload.mood_text = "looking for something good to eat";
            console.log('üß† Using default mood text');
        }

        if (currentMood && currentMood.detected) {
            payload.mood_ids = currentMood.detected;
            console.log('üß† Including detected moods:', currentMood.detected);
        } else {
            // üî• FALLBACK: Provide default mood ID
            payload.mood_ids = ["HUNGRY"];
            console.log('üß† Using default mood IDs');
        }

        console.log('üì° MCP Request payload:', JSON.stringify(payload, null, 2));
        
        // FIRST: Try your MCP server
        const response = await fetch('https://vfied-mcp-server.onrender.com/v1/recommend', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        });

        console.log('üì° MCP Response status:', response.status);
        
        if (!response.ok) {
            // Get error details
            const errorText = await response.text();
            console.error('‚ùå MCP Error Details:', errorText);
            throw new Error(`MCP server error: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        console.log('‚úÖ MCP response received:', data);
        
        return {
            ...data,
            source: 'mcp',
            interactionId: data.interactionId || Date.now().toString()
        };

    } catch (error) {
        console.error('‚ùå MCP call failed, using fallback:', error);
        
        // Use the fixed fallback
        return await getOpenAIFallback(context);
    }
}

    // üß† SMART Cultural Intelligence - Zero Hardcoding

    async function getOpenAIFallback(context = {}) {
    const userPrefs = getCurrentSettings();
    
    // üî• FIX: Don't reference aiFoodService (that's backend only)
    let locationText = 'your area';
    let countryCode = 'US';
    
    if (userPrefs.location?.city) {
        locationText = userPrefs.location.city;
        countryCode = userPrefs.location.country_code || 'US';
    } else {
        // Check location tag
        const locationTag = document.getElementById('location-tag');
        if (locationTag?.textContent?.includes('Nairobi')) {
            locationText = 'Nairobi';
            countryCode = 'KE';
        } else if (locationTag?.textContent?.includes('London')) {
            locationText = 'London';
            countryCode = 'GB';
        } else if (locationTag?.textContent?.includes('Tokyo')) {
            locationText = 'Tokyo';
            countryCode = 'JP';
        }
    }
    
    console.log(`üîÑ Frontend fallback for ${locationText} (${countryCode})`);
    
    // Smart fallback food database (no hardcoding - pattern based)
    const culturalFoodPatterns = {
        'KE': [
            { emoji: 'üçõ', name: 'Ugali with Sukuma Wiki', category: 'traditional' },
            { emoji: 'ü•©', name: 'Nyama Choma', category: 'grilled' },
            { emoji: 'üçö', name: 'Pilau', category: 'rice' },
            { emoji: 'ü•ò', name: 'Githeri', category: 'beans' },
        ],
        'GB': [
            { emoji: 'üçü', name: 'Fish and Chips', category: 'traditional' },
            { emoji: 'ü•ß', name: 'Shepherd\'s Pie', category: 'comfort' },
            { emoji: 'üç≤', name: 'Bangers and Mash', category: 'comfort' },
        ],
        'JP': [
            { emoji: 'üç±', name: 'Bento Box', category: 'traditional' },
            { emoji: 'üçú', name: 'Ramen', category: 'noodles' },
            { emoji: 'üç£', name: 'Sushi', category: 'traditional' },
        ],
        'US': [
            { emoji: 'üçî', name: 'Classic Burger', category: 'comfort' },
            { emoji: 'üçï', name: 'Pizza', category: 'comfort' },
            { emoji: 'üåÆ', name: 'Tacos', category: 'comfort' },
        ]
    };

    const availableFoods = culturalFoodPatterns[countryCode] || culturalFoodPatterns['US'];
    
    // Filter by dietary restrictions
    let suggestions = [...availableFoods];
    if (userPrefs.dietary && userPrefs.dietary.length > 0) {
        if (userPrefs.dietary.includes('vegetarian')) {
            // Simple vegetarian filtering
            suggestions = suggestions.filter(f => 
                !f.name.toLowerCase().includes('meat') && 
                !f.name.toLowerCase().includes('fish') &&
                !f.name.toLowerCase().includes('chicken')
            );
        }
        if (userPrefs.dietary.includes('vegan')) {
            suggestions = suggestions.filter(f => 
                !f.name.toLowerCase().includes('meat') && 
                !f.name.toLowerCase().includes('fish') &&
                !f.name.toLowerCase().includes('cheese') &&
                !f.name.toLowerCase().includes('milk')
            );
        }
    }

    // If no suggestions left, add safe options
    if (suggestions.length === 0) {
        if (countryCode === 'KE') {
            suggestions = [{ emoji: 'üçõ', name: 'Ugali with Vegetables', category: 'vegetarian' }];
        } else {
            suggestions = [{ emoji: 'ü•ó', name: 'Garden Salad', category: 'vegetarian' }];
        }
    }

    const choice = suggestions[Math.floor(Math.random() * suggestions.length)];
    
    return {
        food: {
            emoji: choice.emoji,
            name: choice.name,
            country: userPrefs.location?.country || (countryCode === 'KE' ? 'Kenya' : 'Local'),
            country_code: countryCode,
            category: choice.category
        },
        description: `${choice.name} is perfect for ${locationText}`,
        culturalNote: `This fits perfectly with ${locationText} food culture`,
        personalNote: userPrefs.dietary.length > 0 
            ? `Matches your ${userPrefs.dietary.join(', ')} preferences`
            : 'Based on your location preferences',
        reason: `Perfect choice for ${locationText} right now`,
        availabilityNote: `Available at local restaurants in ${locationText}`,
        source: 'frontend-fallback',
        location: locationText
    };
}

// üß† AI-POWERED CULTURAL FOOD SUGGESTION
async function getAICulturalSuggestion(locationData, userPrefs, context) {
    const culturalPrompt = buildCulturalFoodPrompt(locationData, userPrefs, context);
    
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${aiFoodService.openaiApiKey}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            model: 'gpt-4o-mini',
            messages: [
                {
                    role: 'system',
                    content: 'You are a global food culture expert. Suggest authentic local foods based on location and preferences. Always respond with valid JSON.'
                },
                {
                    role: 'user',
                    content: culturalPrompt
                }
            ],
            max_tokens: 400,
            temperature: 0.7,
            response_format: { type: 'json_object' }
        })
    });

    if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.status}`);
    }

    const data = await response.json();
    const suggestion = JSON.parse(data.choices[0].message.content);
    
    return formatAISuggestion(suggestion, locationData);
}

// üèóÔ∏è BUILD SMART CULTURAL PROMPT
function buildCulturalFoodPrompt(locationData, userPrefs, context) {
    const location = `${locationData.city}, ${locationData.country}`;
    const dietary = userPrefs.dietary?.length > 0 ? userPrefs.dietary.join(', ') : 'no restrictions';
    
    return `
I need an authentic local food suggestion for someone in ${location}.

REQUIREMENTS:
- Location: ${location}
- Dietary needs: ${dietary}
- Mood: ${context.mood || 'general hunger'}
- Time: ${new Date().getHours()}:00 local time

GUIDELINES:
1. Suggest AUTHENTIC local/regional foods from this specific location
2. Consider what locals actually eat, not tourist food
3. Respect dietary restrictions completely
4. Match the current time of day (breakfast/lunch/dinner/snack)
5. Consider local food availability and culture

RESPOND WITH EXACTLY THIS JSON FORMAT:
{
  "food": {
    "name": "specific local dish name",
    "emoji": "appropriate emoji",
    "category": "meal type"
  },
  "description": "why this fits their situation perfectly",
  "culturalNote": "how this represents local food culture",
  "personalNote": "how this matches their dietary needs/preferences",
  "reason": "why this is perfect right now",
  "availabilityNote": "where to find this locally",
  "confidence": 90
}

Focus on REAL local cuisine, not generic international foods.
`;
}

// üéØ SMART PATTERN-BASED FALLBACK (learns from web data)
async function getPatternBasedSuggestion(locationData, userPrefs, context) {
    try {
        // üåê Smart web lookup for cultural food data
        const culturalData = await fetchCulturalFoodData(locationData);
        return generateSmartSuggestion(culturalData, locationData, userPrefs);
    } catch (error) {
        console.warn('Pattern-based suggestion failed, using minimal fallback');
        return getMinimalFallback(locationData, userPrefs);
    }
}

// üåê FETCH CULTURAL FOOD DATA FROM WEB SOURCES
async function fetchCulturalFoodData(locationData) {
    // Try multiple intelligent sources
    const sources = [
        () => fetchFromWikipediaAPI(locationData),
        () => fetchFromFoodAPI(locationData),
        () => fetchFromOpenDataSources(locationData)
    ];
    
    for (const source of sources) {
        try {
            const data = await source();
            if (data && data.foods?.length > 0) {
                return data;
            }
        } catch (error) {
            console.warn('Source failed, trying next:', error.message);
        }
    }
    
    throw new Error('No cultural food data sources available');
}

// üìö WIKIPEDIA CUISINE API (free, no key needed)
async function fetchFromWikipediaAPI(locationData) {
    const query = `${locationData.country} cuisine food dishes`;
    const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(query)}`;
    
    const response = await fetch(url, {
        headers: { 'User-Agent': 'VFIED-Cultural-Intelligence/1.0' }
    });
    
    if (!response.ok) throw new Error('Wikipedia API failed');
    
    const data = await response.json();
    return parseWikipediaData(data, locationData);
}

// üçΩÔ∏è FOOD API SOURCES (free tiers)
async function fetchFromFoodAPI(locationData) {
    // Use free APIs like TheMealDB, Spoonacular free tier, etc.
    const region = getRegionFromLocation(locationData);
    const url = `https://www.themealdb.com/api/json/v1/1/filter.php?a=${encodeURIComponent(region)}`;
    
    const response = await fetch(url);
    if (!response.ok) throw new Error('Food API failed');
    
    const data = await response.json();
    return parseMealDBData(data, locationData);
}

// üåç SMART REGION DETECTION
function getRegionFromLocation(locationData) {
    const countryToRegion = {
        // This is the ONLY small lookup table - maps countries to API regions
        'Kenya': 'African', 'Nigeria': 'African', 'South Africa': 'African',
        'Japan': 'Japanese', 'China': 'Chinese', 'India': 'Indian',
        'United Kingdom': 'British', 'France': 'French', 'Italy': 'Italian',
        'United States': 'American', 'Mexico': 'Mexican', 'Canada': 'Canadian'
    };
    
    return countryToRegion[locationData.country] || 'International';
}

// üß† PARSE WIKIPEDIA DATA INTELLIGENTLY
function parseWikipediaData(data, locationData) {
    // Extract food names from Wikipedia extract using NLP patterns
    const extract = data.extract || '';
    const foodPattern = /\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\b/g;
    const foods = [];
    
    let match;
    while ((match = foodPattern.exec(extract)) !== null) {
        const food = match[1];
        // Smart filtering - likely food names
        if (food.length > 3 && !commonWords.includes(food.toLowerCase())) {
            foods.push({
                name: food,
                source: 'wikipedia',
                confidence: 0.7
            });
        }
    }
    
    return { foods, source: 'wikipedia', country: locationData.country };
}

// üçΩÔ∏è PARSE MEAL DB DATA
function parseMealDBData(data, locationData) {
    const meals = data.meals || [];
    const foods = meals.slice(0, 10).map(meal => ({
        name: meal.strMeal,
        source: 'mealdb',
        confidence: 0.9,
        image: meal.strMealThumb
    }));
    
    return { foods, source: 'mealdb', country: locationData.country };
}

// üéØ GENERATE SMART SUGGESTION FROM CULTURAL DATA
function generateSmartSuggestion(culturalData, locationData, userPrefs) {
    let availableFoods = culturalData.foods || [];
    
    // üå± Smart dietary filtering using AI patterns
    if (userPrefs.dietary?.length > 0) {
        availableFoods = availableFoods.filter(food => 
            isLikelyDietaryCompliant(food.name, userPrefs.dietary)
        );
    }
    
    // üìä Smart selection using confidence scores
    const weightedFoods = availableFoods.map(food => ({
        ...food,
        weight: food.confidence * (1 + Math.random() * 0.3) // Add variety
    }));
    
    weightedFoods.sort((a, b) => b.weight - a.weight);
    const selectedFood = weightedFoods[0] || { name: 'Local Specialty', confidence: 0.6 };
    
    return {
        food: {
            emoji: guessEmoji(selectedFood.name),
            name: selectedFood.name,
            country: locationData.country,
            country_code: locationData.country_code,
            category: guessFoodCategory(selectedFood.name)
        },
        description: `${selectedFood.name} is a wonderful choice from ${locationData.city}`,
        culturalNote: `This dish represents authentic ${locationData.country} cuisine`,
        personalNote: userPrefs.dietary?.length > 0 
            ? `Selected to match your ${userPrefs.dietary.join(', ')} preferences`
            : 'Based on local cultural preferences',
        reason: `Perfect local choice for ${locationData.city} right now`,
        availabilityNote: `Available at local restaurants in ${locationData.city}`,
        source: 'smart-cultural-intelligence',
        confidence: Math.round(selectedFood.confidence * 100)
    };
}

// üß† SMART DIETARY COMPLIANCE CHECK (AI-like patterns)
function isLikelyDietaryCompliant(foodName, dietaryRestrictions) {
    const name = foodName.toLowerCase();
    
    for (const restriction of dietaryRestrictions) {
        if (restriction === 'vegetarian') {
            const meatTerms = ['meat', 'chicken', 'beef', 'pork', 'fish', 'lamb', 'turkey'];
            if (meatTerms.some(term => name.includes(term))) return false;
        }
        if (restriction === 'vegan') {
            const animalTerms = ['meat', 'chicken', 'beef', 'cheese', 'milk', 'egg', 'butter'];
            if (animalTerms.some(term => name.includes(term))) return false;
        }
        if (restriction === 'gluten-free') {
            const glutenTerms = ['bread', 'pasta', 'wheat', 'flour'];
            if (glutenTerms.some(term => name.includes(term))) return false;
        }
    }
    
    return true;
}

// üé® SMART EMOJI GUESSING
function guessEmoji(foodName) {
    const name = foodName.toLowerCase();
    
    if (name.includes('rice')) return 'üçö';
    if (name.includes('bread')) return 'üçû';
    if (name.includes('soup')) return 'üç≤';
    if (name.includes('meat') || name.includes('beef')) return 'ü•©';
    if (name.includes('chicken')) return 'üçó';
    if (name.includes('fish')) return 'üêü';
    if (name.includes('vegetable')) return 'ü•¨';
    if (name.includes('curry')) return 'üçõ';
    if (name.includes('noodle')) return 'üçú';
    
    return 'üçΩÔ∏è'; // Default
}

// üìÇ SMART CATEGORY GUESSING
function guessFoodCategory(foodName) {
    const name = foodName.toLowerCase();
    
    if (name.includes('breakfast')) return 'breakfast';
    if (name.includes('soup')) return 'soup';
    if (name.includes('curry')) return 'curry';
    if (name.includes('rice')) return 'rice dish';
    if (name.includes('bread')) return 'bread';
    
    return 'traditional';
}

// üîß HELPER FUNCTIONS
function extractLocationData(userPrefs) {
    if (userPrefs.location?.city) return userPrefs.location;
    
    // Smart extraction from UI
    const locationTag = document.getElementById('location-tag');
    if (locationTag?.textContent) {
        return parseLocationFromUI(locationTag.textContent);
    }
    
    return { city: 'Unknown', country: 'Unknown', country_code: 'US' };
}

function parseLocationFromUI(tagText) {
    // Smart parsing without hardcoding all combinations
    const parts = tagText.split(' ');
    const cityName = parts[parts.length - 1]; // Usually last word
    
    // You could enhance this with a small city->country lookup or API call
    return {
        city: cityName,
        country: 'Unknown', // This could be enhanced with a geocoding API
        country_code: 'US'
    };
}

// üîÑ MINIMAL FALLBACK (last resort)
function getMinimalFallback(locationData, userPrefs) {
    const isVegetarian = userPrefs.dietary?.includes('vegetarian');
    const basicFood = isVegetarian ? 'Vegetable Curry' : 'Local Specialty';
    
    return {
        food: {
            emoji: isVegetarian ? 'ü•ò' : 'üçΩÔ∏è',
            name: basicFood,
            country: locationData.country || 'Local',
            country_code: locationData.country_code || 'US'
        },
        description: `${basicFood} is a great choice for ${locationData.city || 'your area'}`,
        culturalNote: 'A local favorite that represents regional cuisine',
        personalNote: 'Selected based on your preferences and location',
        reason: 'Perfect choice for your current situation',
        availabilityNote: 'Available at local restaurants',
        source: 'minimal-fallback'
    };
}

// üö´ FILTER COMMON WORDS (to avoid suggesting "The" as a food)
const commonWords = ['the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'been', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'can', 'must', 'shall', 'this', 'that', 'these', 'those', 'cuisine', 'food', 'dish', 'meal', 'cooking'];

    // ==================== MAIN APP WITH REAL AI ====================
    
    class VFIEDRealApp {
        constructor() {
            this.currentSuggestion = null;
            this.isThinking = false;
            this.userPreferences = {};
            this.init();
        }

        init() {
            console.log('ü§ñ VFIED REAL AI App initializing...');
            this.loadUserPreferences();
            this.setupEventListeners();
            this.hideLoadingScreen();
        }

        loadUserPreferences() {
            this.userPreferences = getCurrentSettings();
            console.log('‚öôÔ∏è Loaded user preferences:', this.userPreferences);
        }

        updatePreferences(newPreferences) {
            this.userPreferences = { ...this.userPreferences, ...newPreferences };
            console.log('‚öôÔ∏è Updated app preferences:', this.userPreferences);
            this.updateContextInfo();
        }

        setupEventListeners() {
            // FIXED: Ensure button is always clickable
            const decideButton = document.getElementById('decide-button');
            if (decideButton) {
                // FORCE button to work - multiple methods
                decideButton.style.pointerEvents = 'auto';
                decideButton.style.cursor = 'pointer';
                
                // Remove any existing listeners
                const newButton = decideButton.cloneNode(true);
                decideButton.parentNode.replaceChild(newButton, decideButton);
                
                // Add fresh listener
                const freshButton = document.getElementById('decide-button');
                freshButton.addEventListener('click', (e) => {
                    console.log('üéØ REAL AI BUTTON CLICKED!');
                    e.preventDefault();
                    e.stopPropagation();
                    this.handleDecideClick();
                });
                
                // Force clickability
                freshButton.style.pointerEvents = 'auto';
                freshButton.style.cursor = 'pointer';
                
                console.log('‚úÖ Real AI button setup complete');
            }

            const acceptBtn = document.getElementById('accept-btn');
            const tryAgainBtn = document.getElementById('try-again-btn');
            const insightsToggle = document.getElementById('insights-toggle');
            
            if (acceptBtn) {
                acceptBtn.addEventListener('click', () => this.handleAccept());
            }
            if (tryAgainBtn) {
                tryAgainBtn.addEventListener('click', () => this.handleTryAgain());
            }
            if (insightsToggle) {
                insightsToggle.addEventListener('click', () => this.toggleInsights());
            }

            // Listen for settings updates
            window.addEventListener('vfied-settings-updated', (event) => {
                console.log('‚öôÔ∏è Settings updated event received:', event.detail);
                this.updatePreferences(getCurrentSettings());
            });
        }

        async handleDecideClick() {
          if (this.isThinking) {
              console.log('‚è≥ Already thinking, skipping...');
              return;
          }
          
          console.log('üéØ REAL AI BUTTON CLICKED!');
          console.log('üéØ DECISION - Location Debug:');
          console.log('  - User Settings:', userSettings);
          console.log('  - Current Settings:', getCurrentSettings());
          console.log('  - UI Tag:', document.getElementById('location-tag')?.textContent);
          
          await this.triggerHaptic();
          this.startThinking();
          
          const startTime = Date.now();
          
          try {
              let suggestion;
              
              // üöÄ LAYER 1: ALWAYS TRY FRESH MCP SERVER CALL
              console.log('üöÄ LAYER 1: Attempting FRESH MCP Server AI...');
              
              // üî• REMOVED: Cached mood suggestion check - always get fresh AI
              // The old code was: if (currentMood && currentMood.suggestion) { ... }
              // Now we ALWAYS call the server for fresh suggestions
              
              this.updateButtonState('üöÄ AI THINKING...', 'Getting fresh AI suggestion...');
              
              // üî• FIX: Create proper context for MCP call
              const userPrefs = getCurrentSettings();
              const effectiveLocation = userPrefs.location || this.getEffectiveLocation();
              
              console.log('üåç Using effective location:', effectiveLocation);
              
              const context = {
                  includeRestaurants: true,
                  culturalPriority: true,
                  quick: true,
                  dietary: userPrefs.dietary || [],
                  budget: 'medium',
                  location: effectiveLocation,
                  userId: 'user_' + Date.now(),
                  mood: currentMood,
                  defaultLocation: effectiveLocation,
                  fresh: true // üî• Force fresh suggestion
              };
              
              console.log('üìã MCP Context (FRESH):', JSON.stringify(context, null, 2));

              try {
                  // üöÄ FRESH MCP CALL - No caching!
                  console.log('üì° Making FRESH MCP request...');
                  suggestion = await getAIQuickDecision(context);
                  
                  // üî• CLEAR OLD CACHE after getting fresh suggestion
                  if (currentMood) {
                      delete currentMood.suggestion; // Remove cached suggestion
                      console.log('üßπ Cleared cached suggestion, using fresh AI');
                  }
                  
                  this.currentInteractionId = suggestion.interactionId || Date.now().toString();
                  console.log(`‚ö° FRESH MCP AI success in ${Date.now() - startTime}ms:`, suggestion);
                  
              } catch (mcpError) {
                  console.warn('‚ö†Ô∏è LAYER 1 FAILED (MCP):', mcpError);
                  
                  try {
                      // üîÑ LAYER 2: SMART FRONTEND FALLBACK
                      console.log('üîÑ LAYER 2: Trying smart fallback...');
                      this.updateButtonState('üîÑ SMART BACKUP...', 'Using fallback intelligence...');
                      
                      suggestion = await getOpenAIFallback(context);
                      this.currentInteractionId = Date.now().toString();
                      console.log('‚úÖ Smart fallback succeeded:', suggestion);
                      
                  } catch (fallbackError) {
                      console.warn('‚ö†Ô∏è LAYER 2 FAILED (Smart Fallback):', fallbackError);
                      
                      // üõ°Ô∏è LAYER 3: LOCAL FALLBACK
                      console.log('üõ°Ô∏è LAYER 3: Using local fallback...');
                      this.updateButtonState('üéØ LOCAL MODE...', 'Using built-in intelligence...');
                      
                      suggestion = this.getLocalFallback();
                      this.currentInteractionId = Date.now().toString();
                      console.log('‚úÖ Local fallback succeeded:', suggestion);
                  }
              }
              
              this.currentSuggestion = suggestion;
              
              // Update performance metrics
              this.updatePerformanceMetrics(Date.now() - startTime, true);
              
              // Show suggestion with minimal delay
              const thinkingTime = 800; // Consistent thinking time
              setTimeout(() => {
                  this.showSuggestion(suggestion);
                  this.stopThinking();
                  
                  // üß† ADD MOOD CONTEXT IF AVAILABLE
                  if (currentMood) {
                      const moodContext = document.getElementById('mood-context');
                      const moodMatchText = document.getElementById('mood-match-text');
                      
                      if (moodContext && moodMatchText) {
                          moodMatchText.innerHTML = `üß† <strong>Mood Match:</strong> Perfect for when you're ${currentMood.text}`;
                          moodContext.classList.remove('hidden');
                      }
                  }
              }, thinkingTime);
              
          } catch (finalError) {
              console.error('üö® ALL LAYERS FAILED:', finalError);
              
              // Emergency fallback code stays the same...
              this.showError('All AI systems temporarily unavailable. Please try again.');
              this.stopThinking();
          }
      }
      updateButtonState(text, subtitle) {
          const buttonText = document.getElementById('button-text');
          const buttonIcon = document.getElementById('button-icon');
          const button = document.getElementById('decide-button');
          
          if (buttonText) buttonText.textContent = text;
          if (buttonIcon) buttonIcon.textContent = 'ü§ñ';
          if (button) button.classList.add('thinking');
      }

      getEffectiveLocation() {
          // Try to get location from various sources
          const userPrefs = getCurrentSettings();
          if (userPrefs.location) return userPrefs.location;
          
          // Parse from UI tag
          const locationTag = document.getElementById('location-tag');
          if (locationTag?.textContent?.includes('Nairobi')) {
              return { city: 'Nairobi', country: 'Kenya', country_code: 'KE' };
          } else if (locationTag?.textContent?.includes('London')) {
              return { city: 'London', country: 'United Kingdom', country_code: 'GB' };
          }
          
          // Default fallback
          return { city: 'London', country: 'United Kingdom', country_code: 'GB' };
      }

      getLocalFallback() {
          const userPrefs = getCurrentSettings();
          const location = userPrefs.location || this.getEffectiveLocation();
          
          // Simple local fallback based on location
          const localFoods = {
              'KE': { emoji: 'üçõ', name: 'Ugali with Sukuma Wiki' },
              'GB': { emoji: 'üçü', name: 'Fish and Chips' },
              'JP': { emoji: 'üçú', name: 'Ramen' },
              'US': { emoji: 'üçî', name: 'Classic Burger' }
          };
          
          const countryCode = location.country_code || 'GB';
          const food = localFoods[countryCode] || localFoods['GB'];
          
          return {
              food: {
                  emoji: food.emoji,
                  name: food.name,
                  country: location.country || 'Local',
                  country_code: countryCode
              },
              description: `${food.name} is a great choice for ${location.city || 'your area'}`,
              reason: 'Perfect local choice for your situation',
              source: 'local-fallback'
          };
      }

      updatePerformanceMetrics(responseTime, success) {
          // Simple performance tracking
          this.performanceMetrics = this.performanceMetrics || { totalRequests: 0, avgResponseTime: 0 };
          this.performanceMetrics.totalRequests++;
          
          if (success) {
              const prevAvg = this.performanceMetrics.avgResponseTime || 0;
              const count = this.performanceMetrics.totalRequests;
              this.performanceMetrics.avgResponseTime = (prevAvg * (count - 1) + responseTime) / count;
          }
          
          console.log('üìä Performance:', this.performanceMetrics);
      }

      async triggerHaptic() {
          // Simple haptic feedback (optional)
          try {
              if (navigator.vibrate) {
                  navigator.vibrate(50);
              }
          } catch (error) {
              // Ignore haptic errors
          }
      }
        startThinking() {
            this.isThinking = true;
            const button = document.getElementById('decide-button');
            const buttonText = document.getElementById('button-text');
            const buttonIcon = document.getElementById('button-icon');
            
            if (button) button.classList.add('thinking');
            if (buttonText) buttonText.textContent = 'AI THINKING...';
            if (buttonIcon) buttonIcon.textContent = 'ü§ñ';
            
            const locationText = this.userPreferences.location ? this.userPreferences.location.city : 'your area';
            this.updateContextInfo(`üß† AI analyzing ${locationText}, weather, and your preferences...`);
        }

        stopThinking() {
            this.isThinking = false;
            const button = document.getElementById('decide-button');
            const buttonText = document.getElementById('button-text');
            const buttonIcon = document.getElementById('button-icon');
            
            if (button) button.classList.remove('thinking');
            if (buttonText) buttonText.textContent = 'DECIDE FOR ME';
            if (buttonIcon) buttonIcon.textContent = 'üéØ';
            
            // CRITICAL: Force button to stay clickable
            if (button) {
                button.style.pointerEvents = 'auto';
                button.style.cursor = 'pointer';
            }
        }

        showSuggestion(suggestion) {
            const suggestionResult = document.getElementById('suggestion-result');
            const resultEmoji = document.getElementById('result-emoji');
            const resultName = document.getElementById('result-name');
            const resultDescription = document.getElementById('result-description');
            const restaurantInfo = document.getElementById('restaurant-info');
            
            if (resultEmoji) resultEmoji.textContent = suggestion.food?.emoji || 'üçΩÔ∏è';
            if (resultName) resultName.textContent = suggestion.food?.name || 'Great Choice!';
            if (resultDescription) resultDescription.textContent = suggestion.description || 'Perfect choice for you!';
            if (restaurantInfo) {
                restaurantInfo.textContent = suggestion.availabilityNote || 'Available in your area';
                restaurantInfo.style.display = 'block';
            }
            
            if (suggestionResult) {
                suggestionResult.classList.remove('hidden');
            }
            
            const locationText = suggestion.location || 'your area';
            const source = suggestion.source === 'mcp' ? 'AI+MCP' : 'AI';
            this.updateContextInfo(`üéâ ${source} found perfect choice for ${locationText}! How does this sound?`);
        }

        handleAccept() {
            console.log('‚úÖ Accept clicked');
            alert('Great choice! Enjoy your meal! üéâ');
            
            const suggestionResult = document.getElementById('suggestion-result');
            if (suggestionResult) {
                suggestionResult.classList.add('hidden');
            }
            
            this.updateContextInfo('üéâ Decision made! Time to eat!');
        }

        handleTryAgain() {
            console.log('üîÑ Try again clicked');
            
            const suggestionResult = document.getElementById('suggestion-result');
            if (suggestionResult) {
                suggestionResult.classList.add('hidden');
            }
            
            this.handleDecideClick();
        }

        toggleInsights() {
            const insightsContent = document.getElementById('insights-content');
            const toggle = document.getElementById('insights-toggle');
            
            if (insightsContent && toggle) {
                const isHidden = insightsContent.classList.contains('hidden');
                
                if (isHidden) {
                    insightsContent.classList.remove('hidden');
                    toggle.textContent = 'ü§ñ Hide insights ‚Üë';
                    
                    const culturalNote = document.getElementById('cultural-note');
                    const personalNote = document.getElementById('personal-note');
                    const weatherNote = document.getElementById('weather-note');
                    
                    if (this.currentSuggestion) {
                        if (culturalNote && this.currentSuggestion.culturalNote) {
                            culturalNote.innerHTML = `<strong>üåç Cultural insight:</strong> ${this.currentSuggestion.culturalNote}`;
                            culturalNote.style.display = 'block';
                        }
                        if (personalNote && this.currentSuggestion.personalNote) {
                            personalNote.innerHTML = `<strong>üß† Personal pattern:</strong> ${this.currentSuggestion.personalNote}`;
                            personalNote.style.display = 'block';
                        }
                        if (weatherNote && this.currentSuggestion.reason) {
                            weatherNote.innerHTML = `<strong>üéØ Why this works:</strong> ${this.currentSuggestion.reason}`;
                            weatherNote.style.display = 'block';
                        }
                    }
                } else {
                    insightsContent.classList.add('hidden');
                    toggle.textContent = 'ü§ñ Why this choice? ‚Üì';
                }
            }
        }

        showError(message) {
            this.updateContextInfo(`‚ö†Ô∏è ${message}`);
            setTimeout(() => {
                const locationText = this.userPreferences.location ? this.userPreferences.location.city : 'your area';
                this.updateContextInfo(`ü§ñ Ready to help with ${locationText} food suggestions`);
            }, 3000);
        }

        updateContextInfo(message) {
            const contextInfo = document.getElementById('context-info');
            if (contextInfo) {
                contextInfo.textContent = message;
            }
        }

        hideLoadingScreen() {
            setTimeout(() => {
                const loadingScreen = document.getElementById('loading-screen');
                const mainApp = document.getElementById('main-app');
                
                if (loadingScreen && mainApp) {
                    loadingScreen.style.opacity = '0';
                    loadingScreen.style.transition = 'opacity 0.5s ease';
                    
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        mainApp.classList.remove('hidden');
                        mainApp.style.opacity = '1';
                        
                        // Force button clickability after showing app
                        const button = document.getElementById('decide-button');
                        if (button) {
                            button.style.pointerEvents = 'auto';
                            button.style.cursor = 'pointer';
                        }
                    }, 500);
                }
            }, 2000);
        }
    }

    // ==================== INITIALIZATION ====================
    
    document.addEventListener('DOMContentLoaded', () => {
        console.log('‚öôÔ∏è Initializing REAL AI VFIED system...');
        
        // Initialize settings first
        loadSettings();
        updateSettingsDisplay();
        setupSettingsPanel();
        
        // Make settings available globally
        window.vfiedUserSettings = {
            get: getCurrentSettings,
            update: updateSettingsDisplay,
            raw: () => userSettings,
            notify: notifyMainApp
        };
        
        // Initialize REAL AI app
        window.vfiedAppInstance = new VFIEDRealApp();
        
        // EMERGENCY button fix - runs every 3 seconds
        setInterval(() => {
            const btn = document.getElementById('decide-button');
            if (btn && !window.vfiedAppInstance?.isThinking) {
                btn.style.pointerEvents = 'auto';
                btn.style.cursor = 'pointer';
            }
        }, 3000);
        
        console.log('‚úÖ REAL AI VFIED system ready - MCP + OpenAI integrated!');
    });

    let currentMood = null;
let moodHistory = [];

// üß† MOOD DETECTION FUNCTIONS

// QUICK MOOD SELECTION
function quickMood(mood) {
    const moodInput = document.getElementById('mood-input');
    const moodMap = {
        'tired': 'üò¥ feeling exhausted and need energy',
        'stressed': 'üò∞ feeling overwhelmed and need comfort',
        'celebrating': 'üéâ celebrating something special',
        'post-workout': 'üí™ just finished working out',
        'hungry': 'ü§§ really hungry and need to eat'
    };
    
    if (moodInput) {
        moodInput.value = moodMap[mood] || mood;
        moodInput.style.background = 'rgba(255, 255, 255, 0.25)';
        
        // Auto-detect after setting
        setTimeout(() => {
            detectMoodFromText();
        }, 300);
    }
}

// üß† MOOD DETECTION FUNCTION
async function detectMoodFromText(text = null) {
    const moodInput = document.getElementById('mood-input');
    const detectedMoodsDiv = document.getElementById('detected-moods');
    
    const moodText = text || moodInput?.value?.trim();
    
    if (!moodText) {
        showMoodError('Please enter how you\'re feeling first');
        return;
    }

    try {
        // Show loading state
        if (detectedMoodsDiv) {
            detectedMoodsDiv.classList.remove('hidden');
            detectedMoodsDiv.innerHTML = '<div class="mood-loading">üß† AI analyzing your mood...</div>';
        }

        console.log('üß† Detecting mood for:', moodText);

        // üöÄ CALL YOUR MCP SERVER FOR MOOD DETECTION
        const moodResult = await callMoodDetection(moodText);
        
        // Display detected moods
        displayDetectedMoods(moodResult);
        
        // Store current mood for decision making
        currentMood = {
            text: moodText,
            detected: moodResult.moods,
            timestamp: Date.now(),
            suggestion: moodResult.suggestion // Bonus: we already have a suggestion!
        };
        
        // Add to mood history
        moodHistory.unshift(currentMood);
        if (moodHistory.length > 10) moodHistory.pop();
        
        console.log('üß† Mood detected:', currentMood);
        
    } catch (error) {
        console.error('Mood detection failed:', error);
        showMoodError('Mood detection failed. Using fallback...');
        
        // Fallback to simple mood detection
        currentMood = {
            text: moodText,
            detected: simpleMoodFallback(moodText),
            timestamp: Date.now()
        };
        
        displayDetectedMoods({ moods: currentMood.detected, confidence: 70 });
    }
}

// üöÄ CALL MCP SERVER FOR MOOD DETECTION
async function callMoodDetection(moodText) {
    try {
        const userPrefs = getCurrentSettings();
        
        const response = await fetch('https://vfied-mcp-server.onrender.com/v1/recommend', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                location: userPrefs.location || {
                    city: 'London',
                    country: 'United Kingdom',
                    country_code: 'GB'
                },
                mood_text: moodText, // üéØ This triggers OpenAI mood detection on server
                dietary: userPrefs.dietary || [],
                budget: 'medium',
                menu_source: 'global_database'
            })
        });

        if (!response.ok) {
            throw new Error(`Mood API error: ${response.status}`);
        }

        const result = await response.json();
        
        return {
            moods: result.context?.resolved_moods || ['HUNGRY'],
            suggestion: result, // Bonus: we get the food suggestion too!
            confidence: result.confidence || 85
        };

    } catch (error) {
        console.error('MCP mood detection failed:', error);
        throw error;
    }
}

// üì± DISPLAY DETECTED MOODS
function displayDetectedMoods(moodResult) {
    const detectedMoodsDiv = document.getElementById('detected-moods');
    if (!detectedMoodsDiv) return;

    const moodEmojis = {
        'TIRED': 'üò¥',
        'STRESSED': 'üò∞', 
        'CELEBRATING': 'üéâ',
        'HUNGRY': 'ü§§',
        'POST_WORKOUT': 'üí™',
        'SICK': 'ü§í',
        'FOCUSED': 'üéØ',
        'RELAX': 'üòå',
        'ADVENTUROUS': 'üåü'
    };

    const moodTags = moodResult.moods.map(mood => {
        const emoji = moodEmojis[mood] || 'üòä';
        return `<span class="mood-tag">${emoji} ${mood.toLowerCase()}</span>`;
    }).join('');

    detectedMoodsDiv.innerHTML = `
        <div class="mood-result">
            <strong>üß† AI detected your mood:</strong>
            <div class="mood-tags">${moodTags}</div>
            <div style="margin: 0.5rem 0; font-size: 0.9rem; opacity: 0.8;">
                Confidence: ${moodResult.confidence}%
            </div>
            <button class="use-mood-btn" onclick="useMoodForDecision()">
                üéØ Get food suggestion for this mood
            </button>
        </div>
    `;
}

// üéØ USE DETECTED MOOD FOR FOOD DECISION
function useMoodForDecision() {
    if (!currentMood) {
        showMoodError('No mood detected yet');
        return;
    }

    // Update button text to show we're using mood
    const buttonText = document.getElementById('button-text');
    const buttonSubtitle = document.querySelector('.button-subtitle');
    
    if (buttonText) buttonText.textContent = 'USING YOUR MOOD';
    if (buttonSubtitle) buttonSubtitle.textContent = `For: ${currentMood.text}`;

    // Clear the mood input to show we're using it
    const moodInput = document.getElementById('mood-input');
    if (moodInput) {
        moodInput.style.background = 'rgba(40, 167, 69, 0.3)';
        moodInput.style.borderColor = 'rgba(40, 167, 69, 0.6)';
    }

    // Update context info
    window.vfiedAppInstance?.updateContextInfo(`üß† Using your mood: ${currentMood.detected.join(', ')}`);

    // If we already have a suggestion from mood detection, use it!
    if (currentMood.suggestion) {
        console.log('üéØ Using suggestion from mood detection:', currentMood.suggestion);
        showMoodAwareSuggestion(currentMood.suggestion);
    } else {
        // Trigger decision with mood context
        handleMoodDecision();
    }
}

// üöÄ HANDLE MOOD-AWARE DECISION
async function handleMoodDecision() {
    if (!currentMood) return;

    try {
        console.log('üß† Getting mood-aware suggestion...');
        
        // Show thinking state
        const button = document.getElementById('decide-button');
        if (button) button.classList.add('thinking');
        
        const userPrefs = getCurrentSettings();
        
        const response = await fetch('https://vfied-mcp-server.onrender.com/v1/recommend', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                location: userPrefs.location,
                mood_text: currentMood.text, // üß† Natural language mood
                mood_ids: currentMood.detected, // üéØ Pre-detected mood IDs
                dietary: userPrefs.dietary || [],
                budget: 'medium',
                social: 'solo',
                menu_source: 'global_database'
            })
        });

        if (!response.ok) {
            throw new Error(`MCP suggestion failed: ${response.status}`);
        }

        const suggestion = await response.json();
        
        console.log('üß† Mood-aware suggestion received:', suggestion);
        
        // Show the suggestion
        setTimeout(() => {
            showMoodAwareSuggestion(suggestion);
            
            // Reset button
            const button = document.getElementById('decide-button');
            if (button) button.classList.remove('thinking');
            resetButtonText();
        }, 1500);

    } catch (error) {
        console.error('Mood-aware decision failed:', error);
        showMoodError('Failed to get mood-aware suggestion');
        
        // Reset button
        const button = document.getElementById('decide-button');
        if (button) button.classList.remove('thinking');
        resetButtonText();
    }
}

// üì± SHOW MOOD-AWARE SUGGESTION
function showMoodAwareSuggestion(suggestion) {
    // Show regular suggestion first
    if (window.vfiedAppInstance) {
        window.vfiedAppInstance.currentSuggestion = suggestion;
        window.vfiedAppInstance.showSuggestion(suggestion);
    }

    // Add mood context to the display
    if (currentMood) {
        const moodContext = document.getElementById('mood-context');
        const moodMatchText = document.getElementById('mood-match-text');
        
        if (moodContext && moodMatchText) {
            moodMatchText.innerHTML = `üß† <strong>Mood Match:</strong> Perfect for when you're ${currentMood.text}`;
            moodContext.classList.remove('hidden');
        }
    }

    // Update context info
    window.vfiedAppInstance?.updateContextInfo('üéâ Perfect mood-aware suggestion ready!');
}

// üîß HELPER FUNCTIONS
function showMoodError(message) {
    const detectedMoodsDiv = document.getElementById('detected-moods');
    if (detectedMoodsDiv) {
        detectedMoodsDiv.classList.remove('hidden');
        detectedMoodsDiv.innerHTML = `<div class="mood-error">‚ö†Ô∏è ${message}</div>`;
        
        setTimeout(() => {
            detectedMoodsDiv.classList.add('hidden');
        }, 3000);
    }
}

function simpleMoodFallback(text) {
    const moodMap = {
        'tired': ['TIRED'],
        'stress': ['STRESSED'],
        'celebrat': ['CELEBRATING'],
        'hungry': ['HUNGRY'],
        'workout': ['POST_WORKOUT'],
        'sick': ['SICK'],
        'focus': ['FOCUSED'],
        'relax': ['RELAX'],
        'adventure': ['ADVENTUROUS']
    };

    const lowerText = text.toLowerCase();
    for (const [key, moods] of Object.entries(moodMap)) {
        if (lowerText.includes(key)) {
            return moods;
        }
    }
    return ['HUNGRY'];
}

function resetButtonText() {
    const buttonText = document.getElementById('button-text');
    const buttonSubtitle = document.querySelector('.button-subtitle');
    
    if (buttonText) buttonText.textContent = 'DECIDE FOR ME';
    if (buttonSubtitle) buttonSubtitle.textContent = "I'll figure it out for you";
}

function getCurrentSettings() {
    const settings = { dietary: userSettings.dietary || [] };

    if (userSettings.location && userSettings.location !== 'custom') {
        if (typeof userSettings.location === 'object') {
            settings.location = userSettings.location;
        } else {
            // Convert string to object format
            const locationMap = {
                'london,uk': { city: 'London', country: 'United Kingdom', country_code: 'GB' },
                'nairobi,ke': { city: 'Nairobi', country: 'Kenya', country_code: 'KE' },
                'tokyo,jp': { city: 'Tokyo', country: 'Japan', country_code: 'JP' },
                'newyork,us': { city: 'New York', country: 'United States', country_code: 'US' },
                'paris,fr': { city: 'Paris', country: 'France', country_code: 'FR' },
                'mumbai,in': { city: 'Mumbai', country: 'India', country_code: 'IN' },
                'lagos,ng': { city: 'Lagos', country: 'Nigeria', country_code: 'NG' },
                'sydney,au': { city: 'Sydney', country: 'Australia', country_code: 'AU' }
            };
            settings.location = locationMap[userSettings.location];
        }
    } else if (userSettings.customLocation) {
        const parts = userSettings.customLocation.split(',').map(s => s.trim());
        if (parts.length >= 2) {
            settings.location = { 
                city: parts[0], 
                country: parts[1], 
                country_code: getCountryCode(parts[1])
            };
        }
    }

    console.log('üìã getCurrentSettings:', settings);
    return settings;
}

// Initialize mood detection button listeners
document.addEventListener('DOMContentLoaded', () => {
    const detectBtn = document.getElementById('detect-mood-btn');
    const moodInput = document.getElementById('mood-input');
    
    if (detectBtn) {
        detectBtn.addEventListener('click', () => detectMoodFromText());
    }
    
    if (moodInput) {
        moodInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                detectMoodFromText();
            }
        });
    }
    
    console.log('üß† Mood detection functions initialized');
});

function getCountryCode(country) {
    const countryMap = {
        'Kenya': 'KE',
        'United Kingdom': 'GB', 
        'UK': 'GB',
        'United States': 'US',
        'USA': 'US',
        'Japan': 'JP',
        'France': 'FR',
        'Germany': 'DE',
        'Nigeria': 'NG',
        'India': 'IN',
        'Australia': 'AU'
    };
    return countryMap[country] || 'US';
}

    </script>
</body>
</html>